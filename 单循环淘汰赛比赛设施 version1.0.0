import const as c ###整个比赛只有有权限者才可以修改的常数包
import datetime

class Round__Match:
    def __init__(self,playerList,savepath=None,livequeue=None,toSave=True,toReport=True,toGet=False,debug=False,REPEAT=None,MAXTIME=None,ROUNDS=None):
        if REPEAT:
            self.REPEAT=REPEAT
        else:
            self.REPEAT=c.REPEAT
        if MAXTIME:
            self.MAXTIME=MAXTIME
        else:
            self.MAXTIME=c.MAXTIME
        if ROUNDS:
           self.ROUNDS=ROUNDS
        else:
            self.ROUNDS=c.ROUNDS
        self.playerList=playerList###我们默认已经按约定写好了这个列表，详见注释1
        if savepath:
            self.savepath=savepath
        else:
            now_time = datetime.datetime.now()
            self.savepath=str(now_time)
        if livequeue:   ##如果给出了非None的livequeue参数就按原来的，否则动态加载”queue“模块
            self.livequeue=livequeue
        else:
            q = __import__('queue').Queue() ##动态加载”queue“模块
            self.livequeue=q
        self.toSave=toSave
        self.toReport=toReport
        self.toGet=toGet
        self.debug=debug
   ###注释1
   ###这里我们对playerList做一点说明：playerList是一个表格，表格的每一个项理论上有六种情况：
   ###   情况一：非元组的情况，此类情况有三种子情况，包括该player.py的绝对路径、相对路径或者一个已经写好的类
   ###   情况二：有元组的情况，此类情况也有三种子情况，第一个元组参数的分类同情况一，第二个元组参数是时间，表现为对后手时间的照顾
   ###  下面，我们假设使用者已经预先给出了需要比赛的最初小组赛的playerlist
   ###注释2
   ###单循环赛制的定义：所有的playerlist中的路径或类对象（或元组的第一项，实质也是路劲或对象）两两相遇，比赛一次，最后给予一定名额出线，再重复这一过程，直到总决赛为止。
    def Normalize__PlayerList(self): ###按单循环赛制，将此轮比赛中的所有的playerlist中提及到的绝对路径或相对路径所对应的小组创建成对应的platform对象，也就是让所有小组走上竞技场，并配好对手，但还未开始。
      Normalize__PlayerList=[]      ###规范化的后的PlayerList，所含对象的性质是一个个搭建好的对战平台platform
      for i in range(len(self.playerList)):###按单循环赛制的定义
           for j in range(i+1,len(self.playerList)):###不跟自己比赛，所以i+1
               ###下面几组条件语句用于确定每个platform的states的初始参数
               ###注###我们读取路径py文件的方式以下是使用的是直接open的方式，但需要怎么去读取这个路径文件，还取决于内核对战部分怎么用代码
               if type(self.playerList[i])==tuple and type(self.playerList[j])==tuple:
                   player1=self.playerList[i][0]
                   player2=self.playerList[j][0]
                   if type(player1)==str and type(player2)==str: ###当player1和player2都是路径类参数时，那么需要读取成类实例
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=open(player2)###根据绝对路径或者相对路径，获取py文件实类2
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
    
                       player1.close()##关闭按路径读入的py文件1
                       player2.close()##关闭按路径读入的py文件2
                   elif type(player1)==str and type(player2)!=str:
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=player2###player2为已读取的类
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                   elif type(player1)!=str and type(player2)==str:
                       player1=player1###player1为读取的类
                       player2=open(player2)###player2为绝对路径或相对路径，并获取py文件的实类2
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player2.close()##关闭按路径读入的py文件2
                   else:
                       player1=player1###player1为读取的类
                       player2=player2###player2为读取的类
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
               elif type(self.playerList[i])!=tuple and type(self.playerList[j])!=tuple:
                   player1=self.playerList[i]
                   player2=self.playerList[j]
                   if type(player1)==str and type(player2)==str: ###当player1和player2都是路径类参数时，那么需要读取成类实例
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=open(player2)###根据绝对路径或者相对路径，获取py文件实类2
                       time01=0###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                       player2.close()##关闭按路径读入的py文件2
                   elif type(player1)==str and type(player2)!=str:
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=player2###player2为已读取的类
                       time01=0###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                   elif type(player1)!=str and type(player2)==str:
                       player1=player1###player1为读取的类
                       player2=open(player2)###player2为绝对路径或相对路径，并获取py文件的实类2
                       time01=0###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player2.close()##关闭按路径读入的py文件2
                   else:
                       player1=player1###player1为读取的类
                       player2=player2###player2为读取的类
                       time01=0###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
               elif type(self.playerList[i])!=tuple and type(self.playerList[j])==tuple:
                   player1=self.playerList[i]
                   player2=self.playerList[j][0]
                   if type(player1)==str and type(player2)==str: ###当player1和player2都是路径类参数时，那么需要读取成类实例
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=open(player2)###根据绝对路径或者相对路径，获取py文件实类2
                       time01=0###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                       player2.close()##关闭按路径读入的py文件2
                   elif type(player1)==str and type(player2)!=str:
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=player2###player2为已读取的类
                       time01=0###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                   elif type(player1)!=str and type(player2)==str:
                       player1=player1###player1为读取的类
                       player2=open(player2)###player2为绝对路径或相对路径，并获取py文件的实类2
                       time01=0###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player2.close()##关闭按路径读入的py文件2
                   else:
                       player1=player1###player1为读取的类
                       player2=player2###player2为读取的类
                       time01=0###竞技者1的罚时
                       time02=self.playerList[j][1]###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
               else:
                   player1=self.playerList[i][0]
                   player2=self.playerList[j]
                   if type(player1)==str and type(player2)==str: ###当player1和player2都是路径类参数时，那么需要读取成类实例
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=open(player2)###根据绝对路径或者相对路径，获取py文件实类2
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                       player2.close()##关闭按路径读入的py文件2
                   elif type(player1)==str and type(player2)!=str:
                       player1=open(player1)###根据绝对路径或者相对路径，获取py文件实类1
                       player2=player2###player2为已读取的类
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1的路径
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player1.close()##关闭按路径读入的py文件1
                   elif type(player1)!=str and type(player2)==str:
                       player1=player1###player1为读取的类
                       player2=open(player2)###player2为绝对路径或相对路径，并获取py文件的实类2
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2的路径
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
                       player2.close()##关闭按路径读入的py文件2
                   else:
                       player1=player1###player1为读取的类
                       player2=player2###player2为读取的类
                       time01=self.playerList[i][1]###竞技者1的罚时
                       time02=0###竞技者2的罚时
                       path1=player1###竞技者1本身的类
                       path2=player2###竞技者2本身的类
                       exception=None###初始时刻预设为None
                       error=False###初始时刻统一设为False
                       time=0###初始时刻统一设为0
                       index1=(i,True)
                       index2=(j,False)
                       states = {True: {'player': player1,'path': path1,'time': time,'time0': time01,'error': error,'exception' : exception,'index': index1},False: {'player': player2, 'path': path2,'time': time,'time0': time02,'error': error, 'exception' : exception, 'index': index2}}
               ###下面确定每个platform的保存路径，这里以作者自己的python文件储存位置为例子，需要修改
               match=self.savepath+"/"+str(i)+"vs"+str(j)+".txt"
               ###下面确定每个platform的livequeue参数,直接把在__init___中统一创建的self.livequeue对象赋过来
               livequeue=self.livequeue
               ###其他参数直接调用照写
               toSave=self.toSave
               MAXTIME=self.MAXTIME
               ROUNDS=self.ROUNDS
               ###初始化一个i与j对战时的平台temp
               temp=Platform(states, match, livequeue, toSave, MAXTIME, ROUNDS)###ROUNDS是总回合数
               ###把该平台添加到总的对战平台表格Normalize__PlayerList中
               Normalize__PlayerList.append(temp) 
      return Normalize__PlayerList 
    def RUNNER(self):   ###主函数，包括运行比赛、输出结果文档等一系列功能
        ###调用正规化玩家列表方法，得到所有对战平台
        allplatforms=self.Normalize__PlayerList()
        allresults={}
        for i in range(len(allplatforms)):
            temptuple=(allplatforms[i].states[True]["index"][0],allplatforms[i].states[False]["index"][0])
            tempijplatforms=[]
            for j in range(self.REPEAT):
                allplatforms[i].play()###运行过程中每个result也自动输出到指定的文件夹，其路径由一开始所给的savepath确定
                tempijplatforms.append(allplatforms[i])
            allresults[temptuple]=tempijplatforms
        if self.toGet==True:   
            return allplatforms###返直接回所有平台此时是一个表格
        if self.toSave==True:  ###是否保存单局详细对局记录文件
            for i in range(len(self.playerList)):###按单循环赛制的定义
                for j in range(i+1,len(self.playerList)):###不跟自己比赛，所以i+1
                    for k in range(len(self.REPEAT)):
                        templog=allresults[(i,j)][k].log###调取每个对战平台的日志对象
                        temppath=self.savepath+"/"+str(i)+str(j)+"log"+".txt"###按路径输出日志为一个txt文档，注意log本质是表格类
                        f=open(temppath,"w")
                        f.writelines(templog)
                        f.close()
        if self.debug==True:###是否生成报错信息报告采用先字典记录后输出为txt的方法，每个三元组（i，j, k）代表i，j队第k次比赛
            bugs={}
            for i in range(len(self.playerList)):###按单循环赛制的定义
                for j in range(i+1,len(self.playerList)):###不跟自己比赛，所以i+1
                    for k in range(self.REPEAT):
                        bugs[(i,j,k)]=(allresults[(i,j)][k].states[True][exception],allresults[(i,j)][k].states[False[exception]])#
            tempath=self.savepath+"/"+"_Exceptions.txt"
            path = tempath	#文件路径
            f = open(path,'w',encoding='utf-8')		#以'w'方式打开文件
            for k,v in bugs:			# 遍历字典中的键值
                s2 = str(v)                 # 把字典的值转换成字符型
                f.write(k+'\n')             # 键和值分行放，键在单数行，值在双数行
                f.write(s2+'\n')			
            f.close()		
        if self.toReport==True:###是否生成全部比赛统计报告
            path=self.savepath+"/"+"_.txt"
            report1=[]  ###比赛的统计报告
            s=0                                  ###总局数
            for i in range(len(self.playerList)):###按单循环赛制的定义
                for j in range(i+1,len(self.playerList)):###不跟自己比赛，所以i+1
                    for k in range(self.REPEAT):
                        s=s+1
                        report1.append([str(s)])
                        report1.append([str(allresults[(i,j)][k].match)])
                        report1.append([str(i)+"vs"+str(j)])
                        report1.append([str(allresults[(i,j)][k].rounds)])
            output = open(path,'w',encoding='gbk')
            for row in report1:###按路径输出report1这个表格为一个txt
                rowtxt = '{}'.format(row[0])
                output.write(rowtxt)
                output.write('\n')
                output.close()
                                            

if __name__ == "__main__":###运行主函数
    LETS__DO__MATCH=Round__Match()
    LETS__DO__MATCH.RUNNER()
    
